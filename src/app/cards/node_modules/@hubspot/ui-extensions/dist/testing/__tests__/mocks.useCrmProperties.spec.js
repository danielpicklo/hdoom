import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { describe, expect, it, vi } from 'vitest';
import { Text, Button } from "../../index.js";
import { createRenderer } from "../index.js";
import { useCrmProperties } from "../../crm/index.js";
function MyComponent() {
    const { properties, isLoading, isRefetching, error, refetch } = useCrmProperties(['firstname', 'lastname']);
    if (isLoading) {
        return _jsx(Text, { children: "Loading..." });
    }
    if (isRefetching) {
        return _jsx(Text, { children: "Refetching..." });
    }
    if (error) {
        return _jsx(Text, { children: "Something went wrong!" });
    }
    return (_jsxs(_Fragment, { children: [_jsxs(Text, { children: ["First name: ", properties.firstname] }), _jsxs(Text, { children: ["Last name: ", properties.lastname] }), _jsx(Button, { testId: "refetchButton", onClick: () => refetch(), children: "Refetch" })] }));
}
describe('mock useCrmProperties', () => {
    it('should provide a default mock implementation', () => {
        const { render } = createRenderer('crm.record.tab');
        const { findAll } = render(_jsx(MyComponent, {}));
        const textNodes = findAll(Text);
        expect(textNodes.length).toEqual(2);
        expect(textNodes[0].text).toEqual('First name: fake_firstname');
        expect(textNodes[1].text).toEqual('Last name: fake_lastname');
    });
    it('should allow mocking the next function result', () => {
        const { render, mocks } = createRenderer('crm.record.tab');
        mocks.useCrmProperties.nextResult({
            properties: {},
            error: new Error('Something went wrong!'),
            isLoading: false,
            isRefetching: false,
            refetch: () => Promise.resolve(),
        });
        const { find } = render(_jsx(MyComponent, {}));
        expect(find(Text).text).toEqual('Something went wrong!');
    });
    it('should allow providing a custom mock function', () => {
        const { render, mocks, findAll } = createRenderer('crm.record.tab');
        mocks.useCrmProperties.willCall((propertyNames) => {
            const properties = propertyNames.reduce((acc, propertyName) => {
                acc[propertyName] = propertyName.toUpperCase();
                return acc;
            }, {});
            return {
                properties,
                error: null,
                isLoading: false,
                isRefetching: false,
                refetch: async () => { },
            };
        });
        render(_jsx(MyComponent, {}));
        const textNodes = findAll(Text);
        const firstNameText = textNodes[0];
        const lastNameText = textNodes[1];
        expect(firstNameText.isMatch(Text) && firstNameText.text).toEqual('First name: FIRSTNAME');
        expect(lastNameText.isMatch(Text) && lastNameText.text).toEqual('Last name: LASTNAME');
    });
    it('should allow tracking refetch calls with a custom spy', () => {
        const { render, mocks, findByTestId } = createRenderer('crm.record.tab');
        const refetchSpy = vi.fn().mockResolvedValue(undefined);
        mocks.useCrmProperties.nextResult({
            properties: { firstname: 'John', lastname: 'Doe' },
            error: null,
            isLoading: false,
            isRefetching: false,
            refetch: refetchSpy,
        });
        render(_jsx(MyComponent, {}));
        findByTestId(Button, 'refetchButton').trigger('onClick');
        expect(refetchSpy).toHaveBeenCalledTimes(1);
    });
    it('should allow mocking isRefetching state during refetch', () => {
        const { render, mocks } = createRenderer('crm.record.tab');
        mocks.useCrmProperties.nextResult({
            properties: {},
            error: null,
            isLoading: false,
            isRefetching: true,
            refetch: async () => { },
        });
        const { find } = render(_jsx(MyComponent, {}));
        expect(find(Text).text).toEqual('Refetching...');
    });
    it('should allow providing a custom refetch implementation', () => {
        const { render, mocks, findByTestId } = createRenderer('crm.record.tab');
        const refetchSpy = vi.fn().mockResolvedValue(undefined);
        const customData = { customKey: 'customValue' };
        mocks.useCrmProperties.nextResult({
            properties: { firstname: 'Test Value', lastname: 'Test' },
            error: null,
            isLoading: false,
            isRefetching: false,
            refetch: async () => {
                await refetchSpy(customData);
            },
        });
        render(_jsx(MyComponent, {}));
        findByTestId(Button, 'refetchButton').trigger('onClick');
        expect(refetchSpy).toHaveBeenCalledTimes(1);
        expect(refetchSpy).toHaveBeenCalledWith(customData);
    });
});
