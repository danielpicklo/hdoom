import { useEffect, useReducer, useMemo, useRef, useCallback } from 'react';
import { fetchCrmProperties, } from "../utils/fetchCrmProperties.js";
import { createMockAwareHook } from "../../internal/hook-utils.js";
const initialState = {
    properties: {},
    error: null,
    isLoading: true,
    isRefetching: false,
};
function crmPropertiesReducer(state, action) {
    switch (action.type) {
        case 'FETCH_START':
            return {
                ...state,
                isLoading: true,
                error: null,
            };
        case 'FETCH_SUCCESS':
            return {
                ...state,
                isLoading: false,
                properties: action.payload,
                error: null,
            };
        case 'FETCH_ERROR':
            return {
                ...state,
                isLoading: false,
                error: action.payload,
                properties: {},
            };
        case 'REFETCH_START':
            return {
                ...state,
                isRefetching: true,
                error: null,
            };
        case 'REFETCH_SUCCESS':
            return {
                ...state,
                isRefetching: false,
                properties: action.payload,
                error: null,
            };
        case 'REFETCH_ERROR':
            return {
                ...state,
                isRefetching: false,
                error: action.payload,
            };
        default:
            return state;
    }
}
const DEFAULT_OPTIONS = {};
/**
 * A hook for using and managing CRM properties.
 */
function useCrmPropertiesInternal(propertyNames, options = DEFAULT_OPTIONS) {
    const [state, dispatch] = useReducer(crmPropertiesReducer, initialState);
    /**
     * HOOK OPTIMIZATION:
     *
     * Create stable references for propertyNames and options to prevent unnecessary re-renders and API calls.
     * Then, external developers can pass inline arrays/objects without worrying about memoization
     * We handle the deep equality comparison ourselves, and return the same object reference when content is equivalent.
     */
    const lastPropertyNamesRef = useRef();
    const lastPropertyNamesKeyRef = useRef();
    const lastOptionsRef = useRef();
    const lastOptionsKeyRef = useRef();
    // Track in-flight refetch to support cancellation
    const refetchAbortRef = useRef(null);
    // Track refetch cleanup function to prevent memory leaks
    const refetchCleanupRef = useRef(null);
    const stablePropertyNames = useMemo(() => {
        if (!Array.isArray(propertyNames)) {
            return propertyNames;
        }
        const sortedNames = [...propertyNames].sort();
        const propertyNamesKey = JSON.stringify(sortedNames);
        if (propertyNamesKey === lastPropertyNamesKeyRef.current) {
            return lastPropertyNamesRef.current;
        }
        lastPropertyNamesKeyRef.current = propertyNamesKey;
        lastPropertyNamesRef.current = sortedNames;
        return sortedNames;
    }, [propertyNames]);
    const stableOptions = useMemo(() => {
        const optionsKey = JSON.stringify(options);
        if (optionsKey === lastOptionsKeyRef.current) {
            return lastOptionsRef.current;
        }
        lastOptionsKeyRef.current = optionsKey;
        lastOptionsRef.current = options;
        return options;
    }, [options]);
    // Fetch the properties
    useEffect(() => {
        let cancelled = false;
        let cleanup = null;
        const fetchData = async () => {
            try {
                dispatch({ type: 'FETCH_START' });
                const result = await fetchCrmProperties(stablePropertyNames, (data) => {
                    if (!cancelled) {
                        dispatch({ type: 'FETCH_SUCCESS', payload: data });
                    }
                }, stableOptions);
                if (!cancelled) {
                    dispatch({ type: 'FETCH_SUCCESS', payload: result.data });
                    cleanup = result.cleanup;
                }
            }
            catch (err) {
                if (!cancelled) {
                    const errorData = err instanceof Error
                        ? err
                        : new Error('Failed to fetch CRM properties');
                    dispatch({ type: 'FETCH_ERROR', payload: errorData });
                }
            }
        };
        fetchData();
        return () => {
            cancelled = true;
            // Call cleanup function to release RPC resources
            if (cleanup) {
                cleanup();
            }
            // Clean up any active refetch subscription
            if (refetchCleanupRef.current) {
                refetchCleanupRef.current();
                refetchCleanupRef.current = null;
            }
        };
    }, [stablePropertyNames, stableOptions]);
    const refetch = useCallback(async () => {
        // Cancel any in-flight refetch
        if (refetchAbortRef.current) {
            refetchAbortRef.current.cancelled = true;
        }
        // Clean up old refetch subscription to prevent memory leaks
        if (refetchCleanupRef.current) {
            refetchCleanupRef.current();
            refetchCleanupRef.current = null;
        }
        // Create new abort signal for this refetch
        const abortSignal = { cancelled: false };
        refetchAbortRef.current = abortSignal;
        try {
            dispatch({ type: 'REFETCH_START' });
            const result = await fetchCrmProperties(stablePropertyNames, (data) => {
                if (!abortSignal.cancelled) {
                    dispatch({ type: 'REFETCH_SUCCESS', payload: data });
                }
            }, stableOptions);
            if (!abortSignal.cancelled) {
                dispatch({ type: 'REFETCH_SUCCESS', payload: result.data });
                // Store cleanup for next refetch or unmount
                refetchCleanupRef.current = result.cleanup;
            }
            else {
                // If cancelled, clean up immediately
                if (result.cleanup) {
                    result.cleanup();
                }
            }
        }
        catch (err) {
            if (!abortSignal.cancelled) {
                const errorData = err instanceof Error
                    ? err
                    : new Error('Failed to refetch CRM properties');
                dispatch({ type: 'REFETCH_ERROR', payload: errorData });
            }
        }
        finally {
            // Clear the abort ref if this is still the current refetch
            if (refetchAbortRef.current === abortSignal) {
                refetchAbortRef.current = null;
            }
        }
    }, [stablePropertyNames, stableOptions]);
    return {
        ...state,
        refetch,
    };
}
export const useCrmProperties = createMockAwareHook('useCrmProperties', useCrmPropertiesInternal);
