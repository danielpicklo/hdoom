import { renderHook, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { useCrmProperties } from "../../../crm/hooks/useCrmProperties.js";
import * as fetchCrmPropertiesModule from "../../../crm/utils/fetchCrmProperties.js";
// Mock the logger module
vi.mock('../../../logger', () => ({
    logger: {
        debug: vi.fn(),
        info: vi.fn(),
        warn: vi.fn(),
        error: vi.fn(),
    },
}));
// Mock the fetchCrmProperties module
vi.mock('../../../crm/utils/fetchCrmProperties');
const mockFetchCrmProperties = vi.fn();
fetchCrmPropertiesModule.fetchCrmProperties = mockFetchCrmProperties;
describe('useCrmProperties', () => {
    let originalError;
    beforeAll(() => {
        // Suppress React act() warning coming from @testing-library/react
        originalError = console.error;
        console.error = (...args) => {
            if (typeof args[0] === 'string' &&
                (args[0].includes('ReactDOMTestUtils.act') ||
                    args[0].includes('was not wrapped in act')))
                return;
            originalError.call(console, ...args);
        };
    });
    beforeEach(() => {
        // Reset the mock before each test
        mockFetchCrmProperties.mockReset();
    });
    afterAll(() => {
        console.error = originalError;
    });
    it('should return the initial values for properties, error, and isLoading', async () => {
        const { result } = renderHook(() => useCrmProperties(['firstname', 'lastname']));
        await waitFor(() => {
            expect(result.current.properties).toEqual({});
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(true);
        });
    });
    it('should successfully fetch and return CRM properties', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'Test value for firstname',
                lastname: 'Test value for lastname',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname', 'lastname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.properties).toEqual({
                firstname: 'Test value for firstname',
                lastname: 'Test value for lastname',
            });
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(false);
        });
    });
    it('should handle fetch errors correctly', async () => {
        const errorMessage = 'Failed to fetch CRM properties';
        mockFetchCrmProperties.mockRejectedValue(new Error(errorMessage));
        const propertyNames = ['firstname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.error).toBeInstanceOf(Error);
            expect(result.current.error?.message).toBe(errorMessage);
            expect(result.current.properties).toEqual({});
            expect(result.current.isLoading).toBe(false);
        });
    });
    it('should update properties when propertiesUpdatedCallback is called', async () => {
        // Capture the callback so we can simulate an external update to CRM properties
        let capturedCallback;
        mockFetchCrmProperties.mockImplementation((_propertyNames, propertiesUpdatedCallback) => {
            capturedCallback = propertiesUpdatedCallback;
            return {
                data: { firstname: 'Initial', lastname: 'Initial' },
                cleanup: vi.fn(),
            };
        });
        const propertyNames = ['firstname', 'lastname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.properties).toEqual({
                firstname: 'Initial',
                lastname: 'Initial',
            });
            expect(result.current.isLoading).toBe(false);
        });
        const updatedProperties = { firstname: 'Updated', lastname: 'Updated' };
        await waitFor(() => {
            if (capturedCallback) {
                capturedCallback?.(updatedProperties);
                expect(result.current.properties).toEqual(updatedProperties);
            }
        });
    });
    it('should update properties when propertiesUpdatedCallback is called with null values', async () => {
        // Capture the callback so we can simulate an external update to CRM properties
        let capturedCallback;
        mockFetchCrmProperties.mockImplementation((_propertyNames, propertiesUpdatedCallback) => {
            capturedCallback = propertiesUpdatedCallback;
            return {
                data: { firstname: 'Initial', lastname: null },
                cleanup: vi.fn(),
            };
        });
        const propertyNames = ['firstname', 'lastname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.properties).toEqual({
                firstname: 'Initial',
                lastname: null,
            });
            expect(result.current.isLoading).toBe(false);
        });
        const updatedProperties = { firstname: null, lastname: 'Updated Value' };
        await waitFor(() => {
            if (capturedCallback) {
                capturedCallback?.(updatedProperties);
                expect(result.current.properties).toEqual(updatedProperties);
            }
        });
    });
    // This will become "should pass formatting options to fetchCrmProperties" in the next PR
    it('should pass formatting options to fetchCrmProperties', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
                lastname: 'Doe',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname', 'lastname'];
        const options = {
            propertiesToFormat: ['firstname'],
        };
        renderHook(() => useCrmProperties(propertyNames, options));
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledWith(propertyNames, expect.any(Function), options);
        });
    });
    it('should use default empty options when no options provided', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname'];
        const defaultOptions = {};
        renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledWith(['firstname'], expect.any(Function), defaultOptions);
        });
    });
    it('should not re-fetch when options object reference changes but content is the same', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname'];
        const initialOptions = { propertiesToFormat: ['firstname'] };
        const { rerender } = renderHook(({ options }) => useCrmProperties(propertyNames, options), { initialProps: { options: initialOptions } });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
        });
        const newOptionsWithSameContent = { propertiesToFormat: ['firstname'] };
        rerender({ options: newOptionsWithSameContent });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
        });
    });
    it('should re-fetch when options content actually changes', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname'];
        const initialOptions = { propertiesToFormat: ['firstname'] };
        const { rerender } = renderHook(({ options }) => useCrmProperties(propertyNames, options), { initialProps: { options: initialOptions } });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
            expect(mockFetchCrmProperties).toHaveBeenLastCalledWith(['firstname'], expect.any(Function), initialOptions);
        });
        const newOptions = {
            propertiesToFormat: ['firstname'],
            formattingOptions: { dateFormat: 'yyyy-MM-dd' },
        };
        rerender({ options: newOptions });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(2);
            expect(mockFetchCrmProperties).toHaveBeenLastCalledWith(['firstname'], expect.any(Function), newOptions);
        });
    });
    it('should call cleanup function when component unmounts', async () => {
        const mockCleanup = vi.fn();
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
            },
            cleanup: mockCleanup,
        });
        const propertyNames = ['firstname'];
        const { unmount } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
        });
        unmount();
        expect(mockCleanup).toHaveBeenCalledTimes(1);
    });
    it('should call cleanup function when dependencies change', async () => {
        const mockCleanup1 = vi.fn();
        const mockCleanup2 = vi.fn();
        mockFetchCrmProperties
            .mockResolvedValueOnce({
            data: { firstname: 'John' },
            cleanup: mockCleanup1,
        })
            .mockResolvedValueOnce({
            data: { firstname: 'Jane' },
            cleanup: mockCleanup2,
        });
        const { rerender } = renderHook(({ propertyNames }) => useCrmProperties(propertyNames), { initialProps: { propertyNames: ['firstname'] } });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
        });
        // Change dependencies to trigger cleanup
        rerender({ propertyNames: ['lastname'] });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(2);
            expect(mockCleanup1).toHaveBeenCalledTimes(1);
        });
    });
    it('should handle non-array propertyNames without crashing during stabilization', async () => {
        const errorMessage = 'Properties must be an array of strings';
        mockFetchCrmProperties.mockRejectedValue(new Error(errorMessage));
        const nonArrayPropertyNames = 2;
        const { result } = renderHook(() => 
        // @ts-expect-error - we are deliberately testing a bad type
        useCrmProperties(nonArrayPropertyNames));
        await waitFor(() => {
            expect(result.current.error).toBeInstanceOf(Error);
            expect(result.current.error?.message).toBe(errorMessage);
            expect(result.current.isLoading).toBe(false);
        });
        expect(mockFetchCrmProperties).toHaveBeenCalledWith(2, expect.any(Function), {});
    });
    describe('refetch', () => {
        it('should successfully refetch and update properties', async () => {
            const initialData = { firstname: 'John', lastname: 'Doe' };
            const refetchedData = { firstname: 'Jane', lastname: 'Smith' };
            mockFetchCrmProperties
                .mockResolvedValueOnce({
                data: initialData,
                cleanup: vi.fn(),
            })
                .mockResolvedValueOnce({
                data: refetchedData,
                cleanup: vi.fn(),
            });
            const propertyNames = ['firstname', 'lastname'];
            const { result } = renderHook(() => useCrmProperties(propertyNames));
            await waitFor(() => {
                expect(result.current.properties).toEqual(initialData);
                expect(result.current.isLoading).toBe(false);
                expect(result.current.isRefetching).toBe(false);
            });
            // Call refetch and wait for it to complete
            await result.current.refetch();
            // Wait for state to update with refetched data
            await waitFor(() => {
                expect(result.current.properties).toEqual(refetchedData);
                expect(result.current.isRefetching).toBe(false);
                expect(result.current.error).toBeNull();
            });
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(2);
        });
        it('should set isRefetching to true during refetch', async () => {
            const initialData = { firstname: 'John', lastname: 'Doe' };
            const refetchedData = { firstname: 'Jane', lastname: 'Smith' };
            let resolveRefetch;
            const refetchPromise = new Promise((resolve) => {
                resolveRefetch = resolve;
            });
            mockFetchCrmProperties
                .mockResolvedValueOnce({
                data: initialData,
                cleanup: vi.fn(),
            })
                .mockImplementationOnce(() => refetchPromise);
            const propertyNames = ['firstname', 'lastname'];
            const { result } = renderHook(() => useCrmProperties(propertyNames));
            await waitFor(() => {
                expect(result.current.properties).toEqual(initialData);
                expect(result.current.isLoading).toBe(false);
                expect(result.current.isRefetching).toBe(false);
            });
            // Call refetch but don't await it
            const refetchCall = result.current.refetch();
            // Check that isRefetching is true immediately after calling refetch
            await waitFor(() => {
                expect(result.current.isRefetching).toBe(true);
            });
            // Verify properties haven't changed yet
            expect(result.current.properties).toEqual(initialData);
            expect(result.current.error).toBeNull();
            // Resolve the refetch promise
            resolveRefetch({
                data: refetchedData,
                cleanup: vi.fn(),
            });
            // Wait for refetch to complete
            await refetchCall;
            // Verify isRefetching is false and properties are updated
            await waitFor(() => {
                expect(result.current.isRefetching).toBe(false);
                expect(result.current.properties).toEqual(refetchedData);
            });
        });
        it('should handle refetch errors correctly', async () => {
            const initialData = { firstname: 'John', lastname: 'Doe' };
            const errorMessage = 'Failed to refetch CRM properties';
            mockFetchCrmProperties
                .mockResolvedValueOnce({
                data: initialData,
                cleanup: vi.fn(),
            })
                .mockRejectedValueOnce(new Error(errorMessage));
            const propertyNames = ['firstname', 'lastname'];
            const { result } = renderHook(() => useCrmProperties(propertyNames));
            await waitFor(() => {
                expect(result.current.properties).toEqual(initialData);
                expect(result.current.isLoading).toBe(false);
                expect(result.current.error).toBeNull();
            });
            // Call refetch and wait for it to complete (will throw error)
            await result.current.refetch();
            // Wait for error state to update
            await waitFor(() => {
                expect(result.current.error).toBeInstanceOf(Error);
                expect(result.current.error?.message).toBe(errorMessage);
                expect(result.current.properties).toEqual(initialData);
                expect(result.current.isRefetching).toBe(false);
            });
        });
        it('should clear error on successful refetch', async () => {
            const errorMessage = 'Failed to fetch CRM properties';
            const refetchedData = { firstname: 'Jane', lastname: 'Smith' };
            mockFetchCrmProperties
                .mockRejectedValueOnce(new Error(errorMessage))
                .mockResolvedValueOnce({
                data: refetchedData,
                cleanup: vi.fn(),
            });
            const propertyNames = ['firstname', 'lastname'];
            const { result } = renderHook(() => useCrmProperties(propertyNames));
            await waitFor(() => {
                expect(result.current.error).toBeInstanceOf(Error);
                expect(result.current.error?.message).toBe(errorMessage);
                expect(result.current.isLoading).toBe(false);
            });
            // Call refetch and wait for it to complete
            await result.current.refetch();
            // Wait for error to clear and data to update
            await waitFor(() => {
                expect(result.current.error).toBeNull();
                expect(result.current.properties).toEqual(refetchedData);
                expect(result.current.isRefetching).toBe(false);
            });
        });
        it('should handle multiple rapid refetch calls correctly', async () => {
            const initialData = { firstname: 'John', lastname: 'Doe' };
            const firstRefetchData = { firstname: 'First', lastname: 'Refetch' };
            const secondRefetchData = { firstname: 'Second', lastname: 'Refetch' };
            const initialCleanup = vi.fn();
            const firstRefetchCleanup = vi.fn();
            const secondRefetchCleanup = vi.fn();
            mockFetchCrmProperties
                .mockResolvedValueOnce({
                data: initialData,
                cleanup: initialCleanup,
            })
                .mockResolvedValueOnce({
                data: firstRefetchData,
                cleanup: firstRefetchCleanup,
            })
                .mockResolvedValueOnce({
                data: secondRefetchData,
                cleanup: secondRefetchCleanup,
            });
            const propertyNames = ['firstname', 'lastname'];
            const { result } = renderHook(() => useCrmProperties(propertyNames));
            // Wait for initial fetch to complete
            await waitFor(() => {
                expect(result.current.properties).toEqual(initialData);
                expect(result.current.isLoading).toBe(false);
            });
            // Call refetch twice rapidly (concurrently) - the second should cancel the first
            const firstRefetch = result.current.refetch();
            const secondRefetch = result.current.refetch();
            // Wait for both to complete
            await Promise.all([firstRefetch, secondRefetch]);
            // Verify the final refetch's data is in state
            await waitFor(() => {
                expect(result.current.properties).toEqual(secondRefetchData);
                expect(result.current.isRefetching).toBe(false);
                expect(result.current.error).toBeNull();
            });
            // Verify cancellation behavior: first refetch was cancelled and cleaned up
            expect(firstRefetchCleanup).toHaveBeenCalledTimes(1);
            // Second refetch's cleanup should NOT be called yet (still active subscription)
            expect(secondRefetchCleanup).not.toHaveBeenCalled();
        });
    });
});
