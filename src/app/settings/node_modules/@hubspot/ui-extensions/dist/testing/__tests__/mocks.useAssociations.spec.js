import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { describe, expect, it, vi } from 'vitest';
import { Text, Button } from "../../index.js";
import { createRenderer } from "../index.js";
import { useAssociations } from "../../crm/index.js";
function MyComponent() {
    const { results, isLoading, isRefetching, error, refetch } = useAssociations({
        toObjectType: '0-1',
        properties: ['firstname', 'lastname'],
        pageLength: 10,
    });
    if (isLoading) {
        return _jsx(Text, { children: "Loading..." });
    }
    if (isRefetching) {
        return _jsx(Text, { children: "Refetching..." });
    }
    if (error) {
        return _jsx(Text, { children: "Something went wrong!" });
    }
    return (_jsxs(_Fragment, { children: [results.map((result) => (_jsxs(Text, { children: [result.properties.firstname, " ", result.properties.lastname] }, result.toObjectId))), _jsx(Button, { testId: "refetchButton", onClick: () => refetch(), children: "Refetch" })] }));
}
describe('mock useAssociations', () => {
    it('should provide a default mock implementation', () => {
        const { render } = createRenderer('crm.record.tab');
        const { findAll } = render(_jsx(MyComponent, {}));
        const textNodes = findAll(Text);
        expect(textNodes.length).toEqual(1);
        expect(textNodes[0].text).toEqual('fake_firstname fake_lastname');
    });
    it('should allow mocking the next function result', () => {
        const { render, mocks } = createRenderer('crm.record.tab');
        mocks.useAssociations.nextResult({
            results: [],
            error: new Error('Something went wrong!'),
            isLoading: false,
            isRefetching: false,
            refetch: async () => { },
            pagination: {
                hasNextPage: false,
                hasPreviousPage: false,
                currentPage: 1,
                pageSize: 10,
                nextPage: () => { },
                previousPage: () => { },
                reset: () => { },
            },
        });
        const { find } = render(_jsx(MyComponent, {}));
        expect(find(Text).text).toEqual('Something went wrong!');
    });
    it('should allow tracking refetch calls with a custom spy', () => {
        const { render, mocks, findByTestId } = createRenderer('crm.record.tab');
        const refetchSpy = vi.fn().mockResolvedValue(undefined);
        mocks.useAssociations.nextResult({
            results: [
                {
                    toObjectId: 1,
                    associationTypes: [],
                    properties: { firstname: 'John', lastname: 'Doe' },
                },
            ],
            error: null,
            isLoading: false,
            isRefetching: false,
            refetch: refetchSpy,
            pagination: {
                hasNextPage: false,
                hasPreviousPage: false,
                currentPage: 1,
                pageSize: 10,
                nextPage: () => { },
                previousPage: () => { },
                reset: () => { },
            },
        });
        render(_jsx(MyComponent, {}));
        findByTestId(Button, 'refetchButton').trigger('onClick');
        expect(refetchSpy).toHaveBeenCalledTimes(1);
    });
    it('should allow mocking isRefetching state during refetch', () => {
        const { render, mocks } = createRenderer('crm.record.tab');
        mocks.useAssociations.nextResult({
            results: [],
            error: null,
            isLoading: false,
            isRefetching: true,
            refetch: async () => { },
            pagination: {
                hasNextPage: false,
                hasPreviousPage: false,
                currentPage: 1,
                pageSize: 10,
                nextPage: () => { },
                previousPage: () => { },
                reset: () => { },
            },
        });
        const { find } = render(_jsx(MyComponent, {}));
        expect(find(Text).text).toEqual('Refetching...');
    });
    it('should allow providing a custom refetch implementation', () => {
        const { render, mocks, findByTestId } = createRenderer('crm.record.tab');
        const refetchSpy = vi.fn().mockResolvedValue(undefined);
        const customData = { customKey: 'customValue' };
        mocks.useAssociations.nextResult({
            results: [
                {
                    toObjectId: 1,
                    associationTypes: [],
                    properties: { firstname: 'Test', lastname: 'User' },
                },
            ],
            error: null,
            isLoading: false,
            isRefetching: false,
            refetch: async () => {
                await refetchSpy(customData);
            },
            pagination: {
                hasNextPage: false,
                hasPreviousPage: false,
                currentPage: 1,
                pageSize: 10,
                nextPage: () => { },
                previousPage: () => { },
                reset: () => { },
            },
        });
        render(_jsx(MyComponent, {}));
        findByTestId(Button, 'refetchButton').trigger('onClick');
        expect(refetchSpy).toHaveBeenCalledTimes(1);
        expect(refetchSpy).toHaveBeenCalledWith(customData);
    });
});
